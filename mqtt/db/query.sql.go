// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"
)

const deleteStaleDevices = `-- name: DeleteStaleDevices :exec
DELETE FROM devices WHERE last_seen < datetime('now', '-48 hours')
`

func (q *Queries) DeleteStaleDevices(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteStaleDevices)
	return err
}

const getDevice = `-- name: GetDevice :one
SELECT id, lat, lon, alt, speed, course, sats, hdop, battery_mv, rssi, snr, online, last_seen, created_at FROM devices WHERE id = ? LIMIT 1
`

func (q *Queries) GetDevice(ctx context.Context, id string) (Device, error) {
	row := q.db.QueryRowContext(ctx, getDevice, id)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.Lat,
		&i.Lon,
		&i.Alt,
		&i.Speed,
		&i.Course,
		&i.Sats,
		&i.Hdop,
		&i.BatteryMv,
		&i.Rssi,
		&i.Snr,
		&i.Online,
		&i.LastSeen,
		&i.CreatedAt,
	)
	return i, err
}

const listDevices = `-- name: ListDevices :many
SELECT id, lat, lon, alt, speed, course, sats, hdop, battery_mv, rssi, snr, online, last_seen, created_at FROM devices ORDER BY last_seen DESC
`

func (q *Queries) ListDevices(ctx context.Context) ([]Device, error) {
	rows, err := q.db.QueryContext(ctx, listDevices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Device
	for rows.Next() {
		var i Device
		if err := rows.Scan(
			&i.ID,
			&i.Lat,
			&i.Lon,
			&i.Alt,
			&i.Speed,
			&i.Course,
			&i.Sats,
			&i.Hdop,
			&i.BatteryMv,
			&i.Rssi,
			&i.Snr,
			&i.Online,
			&i.LastSeen,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDeviceOffline = `-- name: MarkDeviceOffline :exec
UPDATE devices SET online = 0 WHERE id = ?
`

func (q *Queries) MarkDeviceOffline(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markDeviceOffline, id)
	return err
}

const upsertDevice = `-- name: UpsertDevice :one
INSERT INTO devices (id, lat, lon, alt, speed, course, sats, hdop, battery_mv, rssi, snr, online, last_seen)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
ON CONFLICT(id) DO UPDATE SET
    lat        = excluded.lat,
    lon        = excluded.lon,
    alt        = excluded.alt,
    speed      = excluded.speed,
    course     = excluded.course,
    sats       = excluded.sats,
    hdop       = excluded.hdop,
    battery_mv = excluded.battery_mv,
    rssi       = excluded.rssi,
    snr        = excluded.snr,
    online     = excluded.online,
    last_seen  = CURRENT_TIMESTAMP
RETURNING id, lat, lon, alt, speed, course, sats, hdop, battery_mv, rssi, snr, online, last_seen, created_at
`

type UpsertDeviceParams struct {
	ID        string  `db:"id" json:"id"`
	Lat       float64 `db:"lat" json:"lat"`
	Lon       float64 `db:"lon" json:"lon"`
	Alt       float64 `db:"alt" json:"alt"`
	Speed     float64 `db:"speed" json:"speed"`
	Course    float64 `db:"course" json:"course"`
	Sats      int64   `db:"sats" json:"sats"`
	Hdop      float64 `db:"hdop" json:"hdop"`
	BatteryMv int64   `db:"battery_mv" json:"battery_mv"`
	Rssi      float64 `db:"rssi" json:"rssi"`
	Snr       float64 `db:"snr" json:"snr"`
	Online    int64   `db:"online" json:"online"`
}

func (q *Queries) UpsertDevice(ctx context.Context, arg UpsertDeviceParams) (Device, error) {
	row := q.db.QueryRowContext(ctx, upsertDevice,
		arg.ID,
		arg.Lat,
		arg.Lon,
		arg.Alt,
		arg.Speed,
		arg.Course,
		arg.Sats,
		arg.Hdop,
		arg.BatteryMv,
		arg.Rssi,
		arg.Snr,
		arg.Online,
	)
	var i Device
	err := row.Scan(
		&i.ID,
		&i.Lat,
		&i.Lon,
		&i.Alt,
		&i.Speed,
		&i.Course,
		&i.Sats,
		&i.Hdop,
		&i.BatteryMv,
		&i.Rssi,
		&i.Snr,
		&i.Online,
		&i.LastSeen,
		&i.CreatedAt,
	)
	return i, err
}
